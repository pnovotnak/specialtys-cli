import argparse
import json
import re
from pathlib import Path
from typing import List, Dict

import bs4
import requests

ROOT_ENDPOINT = 'https://www.specialtys.com'
LOGIN_ENDPOINT = f'{ROOT_ENDPOINT}/Wcf/SSLAuth.ashx'
MENU_ENDPOINT = f'{ROOT_ENDPOINT}/Products.aspx'
PRODUCT_ENDPOINT = f'{ROOT_ENDPOINT}/Wcf/SpProxy.svc/LoadProduct'
CART_ADD_ENDPOINT = f'{ROOT_ENDPOINT}/Wcf/SpProxy.svc/AddProductToLunchcartWithEdits'
CART_LIST_ENDPOINT = f'{ROOT_ENDPOINT}/Wcf/SpProxy.svc/ValidateLunchcart'


def get_authenticated_session(username: str, password: str) -> requests.Session:
    """
    Get an authenticated requests session

    :param username: specialtys.com username
    :param password: specialtys.com password
    :return: Authenticated session
    """
    session = requests.Session()
    session.post(LOGIN_ENDPOINT, data={
        "user": username,
        "password": password,
        # Not sure if this is needed
        "keepMeLoggedIn": True
    })
    return session


def get_cart_contents(session: requests.Session) -> Dict:
    r = session.post(CART_LIST_ENDPOINT, data={})
    r.raise_for_status()
    return r.json()['d']['LunchcartItems']


def get_product_detail(hash_: str) -> str:
    r = requests.post(PRODUCT_ENDPOINT, data={
        'productHash': hash_
    })
    r.raise_for_status()
    return r.json()['d']['Description']


def get_catalog() -> List:
    """
    Generate a product catalog by scraping catalog sections

    :return: catalog
    """
    menuid_re = re.compile(r'^[0-9]+$')
    r = requests.get(f'{ROOT_ENDPOINT}/')
    r.raise_for_status()
    soup = bs4.BeautifulSoup(r.text, 'html.parser')
    menu_links = soup.find(id='productMenu').ul.find_all('a')
    catalog = list()
    for link in menu_links:
        menuid = link.attrs.get('menuid', '')
        if menuid_re.match(menuid):
            catalog.append({
                "name": link.getText().strip(),
                "id": menuid,
                "items": dict()
            })

    for section in catalog:
        id_ = section["id"]
        r = requests.get(f'{MENU_ENDPOINT}?MenuId={id_}')
        r.raise_for_status()
        soup = bs4.BeautifulSoup(r.text, 'html.parser')
        for item in soup.find_all(class_='itemInfo'):
            name = item.find(class_='itemName').getText().strip()
            try:
                price = item.find(class_='itemPrice').getText().strip()
            except AttributeError:
                print(f'No price for: {name}')
                continue
            try:
                hash_ = item.find(class_='customizeButton').attrs['producthash']
            except AttributeError:
                print(f'No hash for: {name}')
                continue
            section['items'][hash_] = {
                "name": name,
                "price": price
            }

    return catalog


def get_order_interactive(catalog: List[dict]) -> List[str]:
    """
    Get a list of product hashes for an order

    :param catalog: Catalog generated by get_catalog()
    :return: List of product hashes
    """
    print('\n\n=> Please choose from the following items:\n')
    for section in catalog:
        print(f'â€¢ {section["name"]}')
        sentinel = False
        for hash_, item in section['items'].items():
            sentinel = True
            print(f'\t- [{hash_}] {item["name"]}')
        if not sentinel:
            print(f'\t[no items?]')

    selections_raw = input('\n\n=> Please enter your selections, separated by spaces: ')
    selections_matched = list()
    for selection in selections_raw.split():
        for section in catalog:
            match = section['items'].get(selection)
            if match:
                selections_matched.append(match)
                break
        else:
            print(f'Unknown product hash: {selection}')
            raise Exception('Bad product hash')
    return selections_matched


def add_item_to_cart(product_hash, edits):
    raise NotImplementedError


def catalog_cache(catalog_cache: str) -> List:
    """
    Load catalog from a cache, if possible. Otherwise, load from specialtys.com

    :param cache_location:
    :return:
    """
    try:
        with open(catalog_cache) as catalog_cache_fp:
            catalog_ = json.load(catalog_cache_fp)
    except IOError:
        print(f'Building catalog cache ({catalog_cache})')
        catalog_ = get_catalog()
        try:
            with open(catalog_cache, 'w') as catalog_cache_fp:
                json.dump(catalog_, catalog_cache_fp)
        except IOError:
            print('Unable to update cache')
        else:
            print(f'Saved catalog cache to disk.')
    else:
        print(f'Loaded catalog cache ({catalog_cache})')
    return catalog_

if __name__ == "__main__":
    user_home = Path.home()
    catalog_cache_f = user_home / '.specialtys-catalog.json'

    parser = argparse.ArgumentParser()
    parser.add_argument('username', type=str, help="Specialties.com username")
    parser.add_argument('password', type=str, help="Specialties.com password")
    args = parser.parse_args()
    session = get_authenticated_session(args.username, args.password)
    cart_contents = get_cart_contents(session)
    print(cart_contents)
    # catalog = catalog_cache(catalog_cache_f)
    # order = get_order_interactive(catalog)
    # get_cart_contents()
    # print(order)
